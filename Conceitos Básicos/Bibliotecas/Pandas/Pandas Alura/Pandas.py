import pandas as pd

'''
O PANDAS POSSUI ALGUNS MÉTODOS PARA QUE A IMPORTAÇÃO DOS DADOS SEJA FEITA, SENDO UM DELES O 'read_csv'. POR PADRÃO, O SEPARADOR DOS DADOS DE UM CSV É UMA VÍRGULA, PORÉM, É IMPORTANTE
VERIFICAR ANTES, JÁ QUE PODE SER QUE ESTEJA COM UM OUTRO SEPARADOR. NO CASO, O COMANDO 'sep', COMO A SEGUIR, É USADO PARA DEFINIR QUAL É O SEPARADOR USADO CASO NÃO SEJA A VÍRGULA.
NO EXEMPLO, É O PONTO E VÍRGULA
'''
url = 'https://raw.githubusercontent.com/alura-cursos/pandas-conhecendo-a-biblioteca/main/base-de-dados/aluguel.csv'
dados = pd.read_csv(url, sep=';')
#print(url)

'''
PODEMOS VISUALIZAR QUANTOS LINHAS E COLUNAS DE DADOS POSSUÍMOS COM O MÉTODO 'shape':
'''
#print(dados.shape) #SAÍDA: 32960 LINHAS, 9 COLUNAS
'''
CASO QUEIRA VISUALIZAR SOMENTE ALGUNS DOS PRIMEIROS OU ÚLTIMOS DADOS, PODEMOS USAR OS SEGUINTE COMANDOS:
'''
# print(dados.head(10))
# print(dados.tail(7))
'''
TANTO O HEAD QUANTO O TAIL, POR PADRÃO, EXIBEM APENAS 5 LINHAS DE DADOS, MAS É POSSÍVEL PASSAR QUANTAS SERÃO AS LINHAS EXIBIDAS NOS ARGUMENTOS
'''
'''
JÁ PARA VISUALIZAR APENAS ALGUMAS DAS COLUNAS DO DATAFRAME, PODEMOS ACESSAR ESSA COLUNA USANDO COLCHETES:
'''
# print(dados['Tipo']) #APENAS UMA COLUNA
# print(dados[['Tipo', 'Bairro', 'Area']]) #MAIS DE UMA COLUNA

'''
PARA EXIBIR INFORMAÇÕES DO DATAFRAME, TEMOS O COMANDO 'info' E O 'dtypes'. COM DTYPES, VEMOS QUAIS OS TIPOS DE DADOS DE CADA COLUNA, JÁ COM O INFO, CONSEGUIMOS VER UM POUCO MAIS DE INFORMAÇÕES
'''
# print(dados.info())
# print(dados.dtypes)


'''
ANÁLISE EXPLORATÓRIA

SE TRATA DE UMA ANÁLISE EM QUE BUSCAMOS ENTENDER COMO OS DADOS ESTÃO ESTRUTURADOS E COMPREENDER CERTAS CARACTERÍSTICAS COMO: VALARES PRESENTES, TIPOS DE ESTRUTURA DE DADOS, SE ELES SÃO QUALITATIVOS OU QUANTITATIVOS,
SE HÁ VALORES FALTANTES OU INCOMUNS. SENDO ASSIM, QUALQUER PERGUNTA SOBRE OS DADOS SÃO BEM-VINDAS E, DE EXEMPLO, IREMOS TOMAR AS DUAS PERGUNTAS A SEGUIR COMO BASE:

1. QUAIS OS VALORES MÉDIOS DE ALUGUEL POR TIPO DE IMÓVEL
2. QUAL O PERCENTUAL POR CADA TIPO DE IMÓVEL NA BASE DE DADOS
'''

'''
1. QUAIS OS VALORES MÉDIOS DE ALUGUEL POR TIPO DE IMÓVEL

ANALISANDO A PERGUNTA, VEMOS QUE OS DADOS QUE MAIS IMPORTAM PARA ESSA QUESTÃO SÃO OS DADOS DA COLUNA 'VALORES' E 'TIPO'. SENDO ASSIM, CONSEGUIMOS FAZER UMA CONSULTA NO DATAFRAME, AGRUPANDO OS DADOS POR TIPO E TIRANDO
A MÉDIA DELES COM OS COMANDOS 'groupby' E 'mean'
'''
# print(dados.groupby('Tipo').mean(numeric_only=True)) #NUMERIC ONLY É USADA PARA GARANTIR QUE APENAS OS VALORES NUMÉRICOS SEJAM AGREGADOS PELA FUNÇÃO MEAN
'''
PODEMOS TAMBÉM VISUALIZAR APENAS A COLUNA DE VALORES, QUE MAIS INTERESSA, E AINDA ORDENAR OS DADOS:
'''
#print(dados.groupby('Tipo')[['Valor']].mean().sort_values('Valor'))
'''
COM ESSA ANÁLISE DOS DADOS, É POSSÍVEL VERIFICAR QUE AS MÉDIAS DE IMÓVEIS COMERCIAIS SÃO BEM MAIORES QUE AS DE IMÓVEIS RESIDENCIAIS, O QUE PODE PREJUDICAR PARA ANÁLISES FUTURAS. SENDO ASSIM, SERÃO FILTRADOS OS VALORES
DOS IMÓVEIS COMERCIAIS PARA QUE APENAS OS RESIDENCIAIS SEJAM EXIBIDOS E TENHAMOS MAIS CLAREZA EM SEUS DADOS.
PARA ISSO, PRECISAMOS DESCOBRIR QUAIS SÃO OS TIPOS IMÓVEIS PRESENTES:
'''
# print(dados.Tipo.unique()) #TAMBÉM É POSSÍVEL ACESSAR UMA COLUNA DA TABELA COM UM PONTO, COMO FOI FEITO AQUI
'''
OS VALORES DE IMÓVEIS COMERCIAIS SERÃO IDENTIFICADOS E ARMAZENADOS EM UMA VARIÁVEL:
'''
imoveisCom = [  'Conjunto Comercial/Sala', 
                'Prédio Inteiro', 'Loja/Salão', 
                'Galpão/Depósito/Armazém', 
                'Casa Comercial', 'Terreno Padrão',
                'Loja Shopping/ Ct Comercial',
                'Box/Garagem', 'Chácara',
                'Loteamento/Condomínio', 'Sítio',
                'Pousada/Chalé', 'Hotel', 'Indústria']

'''
EM SEGUIDA, SERÁ FEITA UMA QUERY COM UTILIZANDO ESSES VALORES. UMA QUERY NADA MAIS É QUE UM MÉTODO DO PANDAS PARA FILTRAR LINHAS ESPECÍFICAS DE UM DATA FRAME COM BASE EM UMA CONDIÇÃO:
'''
dadosResidenciais = dados.query('@imoveisCom not in Tipo') #NA QUERY, AS VARIÁVEIS PRECISAM SEM REFERENCIADAS COM UM @
# print(dadosResidenciais)
'''
AGORA QUE OS DADOS DOS IMÓVEIS COMERCIAIS NÃO IRÃO MAIS IMPACTAR NA ANÁLISE, PODEMOS VERIFICAR NOVAMENTE:
'''
# print(dadosResidenciais.groupby('Tipo')[['Valor']].mean().sort_values('Valor'))
'''
É NOTÁVEL QUE, MESMO QUE AINDA HAJA UMA DIFERENÇA ENTRE OS VALORES, NÃO ESTÁ NADA TÃO IMPACTANTE QUANTO ANTES. ALÉM DISSO, FOI ENCONTRADA A RESPOSTA PARA A PRIMEIRA PERGUNTA:
'''

'''
2. QUAL O PERCENTUAL POR CADA TIPO DE IMÓVEL NA BASE DE DADOS

PARA FAZER A VERIFICAÇÃO DO PERCENTUAL DOS DADOS, FAREMOS UMA CONTAGEM DOS VALORES COM O MÉTODO VALUE_COUNTS:
'''
# print(dadosResidenciais.Tipo.value_counts())
'''
TENDO O TOTAL DE DADOS, BASTA ENTÃO ADICIONAR O ARGUMENTO 'normalize = True' NO VALUE_COUNTS PARA QUE SEJA CONVERTIDO EM PORCENTAGEM. ALÉM DISSO, SERÁ FEITA A ORDENAÇÃO DOS VALORES PELA COLUNA 'TIPO', MAS PARA ISSO
TAMBÉM SERÁ NECESSÁRIO USAR O MÉTODO 'to_frame', PARA CONVERTER A SERIES EM UM DATAFRAME ANTES, PARA QUE AÍ SIM FUNCIONA A ORDENAÇÃO
'''
# print(dadosResidenciais.Tipo.value_counts(normalize=True).to_frame().sort_values('Tipo'))


'''
TRATANDO VALORES NULOS

O TRATAMENTO DE VALORES NULOS EM UMA BASE DE DADOS É EXTREMAMENTE IMPORTANTE PARA QUAISQUER ATIVIDADES QUE ENVOLVAM TAIS DADOS. AFINAL, OS VALORES NULOS PODEM OCASIONAR EM PROBLEMAS COMO ERROS DE TIPOS DE DADOS, 
CAUSAR DIVERGÊNCIAS EM RELATÓRIOS, ETC. PARA FAZER A VERIFICAÇÃO DOS VALORES EM PYTHON, COM O PANDAS, PODEMOS USAR O MÉTODO 'isnull', QUE RETORNA UM BOOLEANO SE HÁ ALGUM RESULTADO É NULO OU NÃO:
'''
# print(dadosResidenciais.isnull())
'''
PARA UMA MELHOR EFICIÊNCIA EM ENCONTRAR SE HÁ TAIS VALORES, PODEMOS FAZER A SOMATÓRIA TOTAL DELES, AO INVÉS DE TER QUE ANÁLISAR O DATA FRAME COMPLETAMENTE
'''
# print(dadosResidenciais.isnull().sum()) SAÍDA:
#                                           Tipo             0
#                                           Bairro           0
#                                           Quartos          0
#                                           Vagas            0
#                                           Suites           0
#                                           Area             0
#                                           Valor            9
#                                           Condominio    1865
#                                           IPTU          6879
'''
ASSIM, FOI VERIFICADO QUE EXISTEM VALORES NULOS NAS COLUNAS 'Valor', 'Condominio' E 'IPTU'. SENDO ASSIM, SERÁ FEITO O TRATAMENTO DOS VALORES, SUBSTITUINDO ELES POR '0' COM A FUNÇÃO 'fillna.
'''
dadosResidenciais = dadosResidenciais.fillna(0)
# print(dadosResidenciais.isnull().sum()) SAÍDA:'
#                                         Tipo          0
#                                         Bairro        0
#                                         Quartos       0
#                                         Vagas         0
#                                         Suites        0
#                                         Area          0
#                                         Valor         0
#                                         Condominio    0
#                                         IPTU          0


'''
REMOVENDO REGISTROS

NA ANÁLISE DE UM DATAFRAME, É POSSÍVEL ENCONTRAR VALORES QUE PODEM E DEVEM SER REMOVIDOS, SEJA PARA EVITAR QUE CAUSEM PROBLEMAS OU PORQUE NÃO HÁ NECESSIDADE QUE ELES SEJAM EXIBIDOS. PRIMEIRO, FAREMOS A REMOÇÃO DOS
DADOS DO DATAFRAME QUE NÃO SÃO DO TIPO APARTAMENTO, ISSO PORQUE, EM ANÁLISES ANTERIORES, FOI VISTO QUE ESTE TIPO É O QUE MAIS ESTÁ PRESENTE, LOGO SERÁ O ÚNICO CONSIDERADO:
'''
#print(dadosResidenciais.query('Tipo == "Apartamento"'))
dfApart = dadosResidenciais.query('Tipo == "Apartamento"')
'''
FOI FEITA A REMOÇÃO APENAS COM A QUERY, DEFININDO UMA NOVA VARIÁVEL COM UM DATAFRAME QUE SERÁ MAIS ÚTIL. AGORA, SERÁ FEITA DE FATO A REMOÇÃO DOS DAOPS, USANDO O MÉTODO 'DROP', QUE RECEBE O ÍNDICE DO QUE SERÁ REMOVIDO
DO DATAFRAME. SENDO ASSIM, USAREMOS NOVAMENTE A QUERY PARA ENCONTRAR QUAIS O ÍNDICES DOS DADOS QUE NÃO POSSUEM VALOR E NEM CONDOMÍNIO:
'''
dadosRemoviveis = dfApart.query('Valor == 0 | Condominio == 0').index
#print(dadosRemoviveis)
'''
ENCONTRADO OS VALORES, SERÃO ENTÃO REMOVIDOS:
'''
dfApart = dfApart.drop(dadosRemoviveis, axis =0)
dfApart = dfApart.drop('Tipo', axis=1)

#print(dfApart.head())
'''
FEITO ENTÃO A REMOÇÃO DOS DADOS E DA COLUNA 'TIPO', QUE NÃO SERIA MAIS NECESSÁRIO AGORA QUE APENAS O TIPO 'APARTAMENTO' ESTÁ SENDO CONSIDERADO. FOI PASSADO OS ÍNDICES PARA REMOÇÃO NO MÉTODO DROP, ALÉM DO ARGUMENTO
'axis', QUE INDICA SE O VALOR É UMA LINHA (0) OU COLUNA (1)
'''

'''
FILTRO DE VALORES

OBVIAMENTE, A QUERY PODE SER USADA PARA FAZER UM FILTRO E ENCONTRAR OS VALORES QUE DESEJA, PORÉM, EXISTE UMA OUTRA FORMA PARA PODER FAZER O FILTRO TAMBÉM. AO SELECIONAR UMA COLUNA DO DATAFRAME COM UMA CONDIÇÃO, 
OS VALORES RETORNADOS SERÃO BOOLEANOS EM UMA SERIES, EM QUE OS VALORES 'TRUE' ESTÃO DE ACORDO COM A CONDIÇÃO ESPECIFICADA E OS VALORES 'FALSE', NÃO.
O FILTRO ACONTECE AO SALVAR ESSA SERIES EM UMA VARIÁVEL E ACESSAR ESSA VARÍAVEL NO DATAFRAME
'''
filtro = dfApart['Quartos'] == 1 #SELECIONANDO APENAS OS VALORES EM QUE O NÚMERO DE QUARTOS É IGUAL A 1 E SALVANDO ESSE VALOR EM UMA VARIÁVEL
#print(dfApart[filtro]) #APLICANDO O FILTRO NO DATAFRAME
'''
É POSSÍVEL FILTRAR MAIS DE UMA CONDIÇÃO TAMBÉM:
'''
filtro = (dfApart['Quartos'] == 1) & (dfApart['Vagas'] == 1) & (dfApart['Valor'] <= 1200)
# print(dfApart[filtro])

'''
SALVANDO OS DADOS

DEPOIS DE FEITAS AS ANÁLISES E ENCONTRAR OS RESULTADOS DESEJADOS, É SEMPRE BOM SALVAR OS VALORES ENCONTRADOS EM UM ARQUIVO. NO CASO, SALVAREMOS EM FORMATO .csv, QUE TAMBÉM FOI UTILIZADO PARA DAR ORIGEM AOS DADOS,
USANDO O MÉTODO 'to_csv()', INFORMANDO O NOME DO ARQUIVO E O FORMATO.
ESSE MÉTODO PODE RECEBER ALGUNS PARÂMETROS, E DOIS DELES QUE SÃO MUITOS INTERESSANTES SÃO O 'index' E O 'sep'. O PRIMEIRO, É USADO PARA PODER INDICAR SE A COLUNA DE INDEX DOS DADOS SERÃO SALVAR TAMBÉM, JÁ QUE AO SALVAR
UMA NOVA COLUNA DE INDEX SERÁ CRIADA PRO NOVO ARQUIVO. CASO ESSES VALORES DE INDEX ANTIGOS NÃO FIZEREM SENTIDO, O PARÂMETRO RECEBE ENTÃO 'false'.
JÁ O 'sep', ASSIM COMO NO MÉTODO 'read_csv()', INDICA O SEPARADOR DOS ARQUIVOS. POR PADRÃO, O CSV É SEPARADO POR VÍRGULAS, MAS PODE SER INDICADO UM OUTRO CARACTERE UTILIZADO COMO SEPARADOR. AQUI, ASSIM COMO FOI FEITO
NO ARQUIVO DE ORIGEM, TAMBÉM USAREMOS O ';'
'''
#dfApart.to_csv('dados_apartamentos.csv', sep=';', index=False)

'''
UM TESTE PODE SER FEITO IMPORTANDO OS DADOS QUE FORAM GERADOS, PARA VERIFICAR SE ESTÁ TUDO CORRETO.
'''
dadosApartamentos = pd.read_csv('dados_apartamentos.csv', sep=';')
#print(dadosApartamentos)


'''
CRIANDO COLUNAS

VOLTANDO AGORA PRO ARQUIVO ORIGINAL, VAMOS IMAGINAR QUE SEJA NECESSÁRIO INSERIR NO DATAFRAME DUAS COLUNAS NOVAS, REFERENTES AOS VALORES QUE SERÃO GASTOS NOS IMÓVEIS POR MÊS E POR ANO. PARA FAZER ISSO É MUITO SIMPLES,
BASTA 'ACESSAR' A NOVA COLUNA COMO SE FOSSE QUALQUER OUTRA, E INSERIR SEU VALOR:
'''
dados['Valor_por_Mes'] = dados['Valor'] + dados['Condominio']
dados['Valor_por_Ano'] = dados.Valor_por_Mes * 12 + dados.IPTU
# print(dados)
'''
POR FIM, VAMOS ADICIONAR AGORA MAIS DUAS COLUNAS, MAS QUE NÃO SÃO MAIS NUMÉRICAS. A PRIMEIRA SERIA UM RESUMO DO TIPO DE IMÓVEL, EM QUAL BAIRRO, COM QUANTOS QUARTOS E VAGAS DE GARAGEM:
'''
dados['Descricao'] = dados.Tipo + ' em ' + dados.Bairro + ' com ' + dados.Quartos.astype(str) + ' quarto(s) e ' + dados.Vagas.astype(str) + ' vagas.'
'''
DOIS DETALHES QUE VALEM SER MENCIONADOS SÃO QUE, CASO O COMANDO FICASSE MUITO GRANDE, PODERIA SER USADO O SÍMBOLO '\' PARA CONTINUAR O COMANDO NA LINHA DE BAIXO, E QUE O USO DO 'astype(str)' PARA CONVERTER OS VALORES
DE 'Quartos' E 'Vagas' PARA STRING É NECESSÁRIO PORQUE APENAS STRINGS SÃO ACEITAS NA CONCATENAÇÃO. CASO NÃO FOSSE USADO O COMANDO, HAVERIA UMA FALHA.

E A OUTRA COLUNA SERIA UMA COLUNA BINÁRIA, QUE RETORNA 'Sim' OU 'Não' CASO HAJA SUÍTE NO IMÓVEL. NESSE CASO, É NECESSÁRIO O USO DE UMA FUNÇÃO LAMBDA PARA FAZER A VERIFICAÇÃO NO CAMPO DE 'Suíte' E RETORNAR O VALOR 
DESEJADO, E PARA ISSO, É USADO O MÉTODO 'apply' PARA PERMITIR INVOCAR UMA FUNÇÃO
'''
dados['Com_Suite'] = dados['Suites'].apply(lambda suite: 'Sim' if suite > 0 else 'Não')
# print(dados)